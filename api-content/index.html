{"posts":[{"title":"icp备案查询接口/自动获取ICP备案号接口的使用","content":"icp备案查询接口 https://api.pph.ink/api/icp 使用方法 请求示例：https://api.pph.ink/api/icp?domain= 请求方式：get 请求参数：domain=需查询的域名，可以包含http或二级 返回示例： { &quot;icp&quot;: &quot;粤B2-20090059-5&quot;, &quot;unitName&quot;: &quot;深圳市腾讯计算机系统有限公司&quot;, &quot;natureName&quot;: &quot;企业&quot;, &quot;msg&quot;: &quot;查询成功&quot;, &quot;result&quot;: &quot;1&quot; } icp备案号自动获取接口 https://api.pph.ink/api/icpbah 使用方法 直接添加在网站备案号处： &lt;a href=&quot;http://beian.miit.gov.cn&quot; target=&quot;_blank&quot;&gt;&lt;script src=&quot;https://api.pph.ink/api/icpbah&quot;&gt;&lt;/script&gt;&lt;/a&gt; ","link":"https://zhx6.github.io/QW-kWbI6i/"},{"title":"Linux一键安装可视化桌面环境支持浏览器及RDP访问","content":"说明 支持：Ubuntu 18.04/20.04 Debian 10 CentOS 7/8； 内存：Ubuntu/Debian 1G以上 CentOS 1.5G以上； 支持浏览器访问，同时支持Windows自带的远程连接通过3389访问； 编译安装Guacamole服务器； 配置Guacamole Web APP； 安装Tomcat 9 XRDP/TigerVNC XFCE4桌面环境及火狐浏览器； 一键安装配置Let's Encrypt安全证书，开启OCSP装订； 支持安装Nginx反代Tomcat； 预览 中文支持 如果需要中文显示，需要修改系统语言，并添加中文字体； 安装中文语言包 apt-get install language-pack-zh* -y apt-get install chinese* -y 安装亚洲字体 apt-get install fonts-arphic-ukai fonts-arphic-uming fonts-ipafont-mincho fonts-ipafont-gothic fonts-unfonts-core -y 重置系统区域 dpkg-reconfigure locales 选择All locales后回车； 选择zh_CN.UTF-8后回车； 等待更新完成后重启服务器； 安装桌面 可以直接使用ROOT用户安装，也可以选择其它系统用户安装； 安装过程都是中文的，根据提示进行设置即可； wget https://raw.githubusercontent.com/Har-Kuun/OneClickDesktop/master/OneClickDesktop_zh-CN.sh &amp;&amp; sudo bash OneClickDesktop_zh-CN.sh 如果出现以下界面，直接回车即可； 安装完成后即可使用http://YOU_IP:8080/guacamole进行访问 Guacamole的登陆账户为安装时自行设定的，然后输入系统用户及密码来完成登录； 其它设置 默认端口修改，编辑文件/etc/tomcat9/server.xml文件修改其中的8080端口后保存 然后使用systemctl restart tomcat9命令重启tomcat即可； 由于现代浏览器的限制无法在本地和网页桌面上进行复制粘贴 解决此问题可以使用带SSL的域名进行反向代理（不过博主设置反代并不成功，尴尬~~） 或者直接使用Internet Explorer浏览器就行，没有复制粘贴的问题 再或者使用Windows系统自带的远程连接也可以解决此问题； 参考链接 https://github.com/Har-Kuun/OneClickDesktop https://qing.su/article/oneclick-desktop.html ","link":"https://zhx6.github.io/f5hKN-uUY/"},{"title":"Go 学习笔记：go module 的基本使用","content":"在 go 的1.11版本中，引入了一个新的依赖管理库go module，用于替换旧的基于 GOPATH 的方法来指定在给定构建中使用哪些源文件，这个特性在1.13版本中被正式推荐使用 在基于GOPATH的方式中，我们需要将项目写到GOPATH下的src文件夹中，但是使用go module之后便可以不用将代码放置到 src 目录下了。使用了go module的项目中，会在项目的目录中生成两个新的文件：go.mod和 go.sum，分别用来记录当前项目的信息（项目名，go 版本号，依赖）和每一个依赖库的哈希值 Ⅰ. 准备工作 但是go module并不是默认开启的，你需要一些简短的设置，在你的终端中执行以下命令： go env -w GO111MODULE=on GO111MODULE 的参数有三个： 参数 描述 on 强制启用 off 强制关闭 auto 对于存在 go.mod 的项目自动启用 启用go module之后，就可以设置 Go Proxy 了，这是 GO 的代理，类比于 Linux 系统的换源 go env -w GOPROXY=https://goproxy.cn,direct 这里使用的是七牛云的一个代理，速度还蛮快的，如果需要使用阿里云的，可以选择这个： go env -w GOPROXY=https://mirrors.aliyun.com/goproxy,direct 检查一下 go 的环境有无正确被配置 go env 检查输出中的GO111MODULE=&quot;on&quot;和GOPROXY=&quot;https://goproxy.cn,direct&quot;是否和我的一致，如果不一致，请自行检查是否前置步骤出现问题 Ⅱ. 开启新的项目 启用go module之后，我们先新建一个文件夹，文件夹名字不重要，因为项目名称已经与这个文件夹无关了，我们先将目录切换到这个文件夹下 cd /myPath/code/myProject 然后新建项目 go mod init &lt;project name&gt; 你会发现文件夹下出现了一个go.mod文件，不要改动它，我们先新建一个文件：app.go touch app.go 往里边随便写点东西 vim app.go package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello world&quot;) } 这只是一个最基础的文件，测试一下是否能正常运行，如果不能正常运行，请自行检查前序步骤 如果我们现在安装一个新的包呢？我们这里用&quot;gitee.com/go-package/carbon&quot;这个包来举例，这是一个处理时间的包，具体链接：carbon: 轻量级、语义化、对开发者友好的 Golang 时间处理库 (gitee.com) 我们这里将上述代码改成： package main import ( &quot;fmt&quot; &quot;gitee.com/go-package/carbon&quot; ) func main() { fmt.Println(carbon.Now()) } 我们保存，然后运行如下代码： go mod tidy 我们打开go.mod文件： module test go 1.13 require gitee.com/go-package/carbon v1.5.4 我们发现，依赖项已经被记录下来了，接下来就是将依赖安装到本地 go mod download 在经过电脑一顿处理以后，依赖像终于被安装上了，这里的依赖会被默认安装到 GOPATH 下，如果你没有设置 GOPATH 的地址，那么 GOPATH 将会使用默认地址 如果安装失败，请检查代理是否有正确设置 如果不想让他被放在 GOPATH 下，我们可以使用 go mod vendor 将依赖移动到当前目录下，这将会自动创建vendor文件夹，用来存放依赖 GO 在 1.5 版本的时候引入了 vendor 模式，如果项目目录下有 vendor 目录，会优先使用 vendor 内的包进行编译与测试 不同于 pip 或者 npm，go module 对于依赖的添加思路是现在文件中写出相关依赖，然后自动安装 Ⅲ. 引入本地包 我们不仅仅能通过网络引入包，也可以引入本地写的包，例如，我现在有一个本地的包myPackage 我们先在这个项目下新建一个文件夹： mkdir myPackage 然后新建一个文件add.go： package mypackage func Add(num1, num2 int) int { return num1, num2 } 如果我们要使用这个包，只需要在项目文件夹下的 app.go 中这样写： package main import ( &quot;fmt&quot; &quot;test/mypackage&quot; // test 是项目名 ) func main() { ans := mypackage.Add(12, 24) fmt.Println(ans) } 尝试运行一下，输出正常了 我们打开go.mod看看，本地引入的包是不会记录到go.mod中的 module test go 1.13 require gitee.com/go-package/carbon v1.5.4 GO MODULE 常用命令 命令 描述 go mod init 初始化 go.mod go mod tidy 更新依赖文件 go mod download 下载依赖文件 go mod vendor 将依赖转移至本地的 vendor 文件 go mod edit 手动修改依赖文件 go mod graph 打印依赖图 go mod verify 校验依赖 参考：go module 基本使用 - 牛奔 - 博客园 (cnblogs.com) ","link":"https://zhx6.github.io/wal4zKKf3/"},{"title":"Go 学习笔记：基于 net 库实现的聊天室","content":"Go 语言的 net 库真是太顶了！ 今天在看 go 的 net 来着，就想顺手实现一个 tcp 聊天室，大致看了一下 net 这个库，发现它实现一个简易的 tcp 聊天室比使用 C 语言之流要简单的多 要想实现一个多人的聊天室，就得先弄明白单个客户端与服务端是如何交互的，这里我们先不使用协程来处理最简单的情况 服务端 package main import ( &quot;fmt&quot; &quot;net&quot; ) func main() { listener, err := net.Listen(&quot;tcp&quot;, &quot;:3000&quot;) // Start listening if err != nil { fmt.Println(err) return } conn, err := listener.Accept() // Waiting for the client to connect (blocking) if err != nil { fmt.Println(err) return } for { buf := make([]byte, 512) length, err := conn.Read(buf) // conn.read(buf) 会将从conn传来的数据传到buf数组中 if err != nil { fmt.Println(err) return } fmt.Println(length, string(buf)) // 将buf中的数据打印出来 if string(buf[:length]) == &quot;end&quot; { break } // 似乎这里会传过来一个换行符号，需要手动给他截掉 } err = conn.Close() // 关闭链接 释放资源 if err != nil { fmt.Println(err) return } } 客户端 package main import ( &quot;fmt&quot; &quot;net&quot; ) func main() { client, err := net.Dial(&quot;tcp&quot;, &quot;localhost:3000&quot;) // 启动客户端并连接服务端 if err != nil { fmt.Println(err) return } defer client.Close() client.Write([]byte(&quot;Hello world&quot;)) // 将数据写入连接（传到服务端） if err != nil { fmt.Println(err) } } 根据上述的原理，我们可以尝试写一个支持多客户端的聊天室（代码有点简陋，若有纰漏之处还请不吝赐教） 服务端 package main import ( &quot;fmt&quot; &quot;net&quot; ) var clients = make(map[net.Conn]bool) var messages = make(chan []byte) func main() { listener, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil { fmt.Println(err) return } go boardcast() for { conn, err := listener.Accept() if err != nil { fmt.Println(err) continue } go handleConnection(conn) } } // 全局广播 func boardcast() { for msg := range messages { for conn, _ := range clients { if _, err := conn.Write(msg); err != nil { fmt.Println(err) continue } } fmt.Println(msg) } } func handleConnection(conn net.Conn) { clients[conn] = true fmt.Println(&quot;[System]:&quot;, conn.RemoteAddr().String(), &quot;进入聊天室&quot;) for { buf := make([]byte, 512) length, err := conn.Read(buf) if err != nil { fmt.Println(err) break } messages &lt;- buf[:length] } delete(clients, conn) fmt.Println(&quot;[System]:&quot;, conn.RemoteAddr().String(), &quot;离去...&quot;) conn.Close() } 客户端 package main import ( &quot;bufio&quot; &quot;fmt&quot; &quot;net&quot; &quot;os&quot; ) func main() { client, err := net.Dial(&quot;tcp&quot;, &quot;localhost:8080&quot;) if err != nil { fmt.Println(err) return } defer client.Close() go func() { input := bufio.NewScanner(os.Stdin) for input.Scan() { client.Write(input.Bytes()) } }() for { buf := make([]byte, 512) length, err := client.Read(buf) if err != nil { fmt.Println(err) } fmt.Println(string(buf[:length])) } } ","link":"https://zhx6.github.io/a7C1TwLnV/"},{"title":"Go 学习笔记：Json 转换","content":"Go 语言是不能像 JavaScript 一样直接支持 Json 这种类型的，需要自己手动将 Json 转换为 Go 语言能支持的数据结构 Json 转换为 map 如果 json 内的字段是确定的，你可以这样写 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { str := `{&quot;name&quot;:&quot;dio&quot;, &quot;age&quot;:&quot;12&quot;}` dict := make(map[string]string) err := json.Unmarshal([]byte(str), &amp;dict) if err != nil { fmt.Println(&quot;ERR:&quot;, err) } else { fmt.Println(dict) } } 如果不能确定，那就用 interface 来替代即可 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { str := `{&quot;name&quot;:&quot;dio&quot;, &quot;age&quot;:12}` dict := make(map[string]interface{}) err := json.Unmarshal([]byte(str), &amp;dict) if err != nil { fmt.Println(&quot;ERR:&quot;, err) } else { // fmt.Println(dict[&quot;age&quot;]) fmt.Printf(&quot;%T\\n&quot;, dict[&quot;age&quot;]) } } Json 转换为切片 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) func main() { str := `[&quot;name&quot;, &quot;value&quot;]` dict := make([]string, 32) err := json.Unmarshal([]byte(str), &amp;dict) if err != nil { fmt.Println(&quot;ERR:&quot;, err) } else { fmt.Println(dict[0]) fmt.Printf(&quot;%T\\n&quot;, dict) } } Json 转结构体 Json 转结构体的时候，需要先声明结构体 package main import ( &quot;encoding/json&quot; &quot;fmt&quot; ) type Dict struct { name string age int32 bobby []string } func main() { str := `{&quot;name&quot;: &quot;dio&quot;, &quot;age&quot;:12, &quot;hobby&quot;:[&quot;Programming&quot;, &quot;dancing&quot;]}` dict := Dict{} err := json.Unmarshal([]byte(str), &amp;dict) if err != nil { fmt.Println(&quot;ERR:&quot;, err) } else { fmt.Printf(&quot;%+v\\n&quot;, dict) fmt.Printf(&quot;%T\\n&quot;, dict) } } ","link":"https://zhx6.github.io/2I4iSMrIW/"},{"title":"Go 学习笔记：net/http 库","content":"Go 语言提供了一个 net 的库，其中的 net/http 库提供了比较完整的 http 协议 GET 请求 package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; ) func main() { httpUrl := &quot;http://httpbin.org/get&quot; res, err := http.Get(httpUrl) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } defer res.Body.Close() // 延迟关闭 content, err := ioutil.ReadAll(res.Body) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } fmt.Println(string(content)) } GET 请求（带 param） get 清求可以直接手动拼接字符串，也可以使用 net 提供的 net/url 库自动拼接 package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/url&quot; ) func main() { httpUrl := &quot;http://httpbin.org/get&quot; param := url.Values{} param.Set(&quot;name&quot;, &quot;dio&quot;) httpUrl2, err := url.ParseRequestURI(httpUrl) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } httpUrl2.RawQuery = param.Encode() res, err := http.Get(httpUrl2.String()) if err != nil { fmt.Println(&quot;Failed:&quot;, err) return } defer res.Body.Close() body, err := ioutil.ReadAll(res.Body) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } fmt.Println(string(body)) } POST 请求 当然，你也可以试着 POST 一下 package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/url&quot; &quot;strings&quot; ) func main() { httpUrl := &quot;http://httpbin.org/post&quot; contentType := &quot;application/x-www-form-urlencoded&quot; data := url.Values{} data.Set(&quot;name&quot;, &quot;dio&quot;) res, err := http.Post(httpUrl, contentType, strings.NewReader(data.Encode())) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } defer res.Body.Close() content, err := ioutil.ReadAll(res.Body) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } fmt.Println(string(content)) } 模拟表单 FORM package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/url&quot; ) func main() { httpUrl := &quot;http://httpbin.org/post&quot; data := url.Values{} data.Set(&quot;name&quot;, &quot;dio&quot;) res, err := http.PostForm(httpUrl, data) if err != nil { fmt.Println(&quot;Fail&quot;, err) return } defer res.Body.Close() content, err := ioutil.ReadAll(res.Body) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } fmt.Println(string(content)) } 自定义 client package main import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; ) var ( client = http.Client{ Transport: &amp;http.Transport{ DisableKeepAlives: false, }, } ) func main() { httpUrl := &quot;http://httpbin.org/get&quot; res, err := client.Get(httpUrl) if err != nil { fmt.Println(&quot;Fail:&quot;, err) return } defer res.Body.Close() content, err := ioutil.ReadAll(res.Body) if err != nil { fmt.Println(&quot;Fail:&quot;, err) } fmt.Println(string(content)) } ","link":"https://zhx6.github.io/-jxjs5WOX/"},{"title":"Go 学习笔记：并发编程","content":"Go 语言提供了更加方便的并发编程方式（goroutine），通过go关键字调用新的协程，而不需要像 java 或者类似的语言去封装一些线程池之类的东西，这使得 go 语言对并发编程显得非常友好 我们可以很方便的新建一个协程 package main import ( &quot;fmt&quot; &quot;time&quot; ) func download() { fmt.Println(&quot;Download begins...&quot;) time.Sleep(time.Second * time.Duration(5)) fmt.Println(&quot;Download successful&quot;) } func main() { fmt.Println(&quot;Main begins...&quot;) go download() fmt.Println(&quot;Main end&quot;) } /* Main begins... Main end */ 通过运行这个程序，我们发现 download 函数好像根本没有运行！这是因为，这个程序在 main 函数推出后就结束了，而通过 go 关键字生成新的协程会花费一定的时间，这就导致，在主协程结束以后，所有的子协程都被强行结束，这就是为什么 download 函数根本没有运行。为了验证这个说法，我们让主协程多跑一会儿 package main import ( &quot;fmt&quot; &quot;time&quot; ) func download() { fmt.Println(&quot;Download begins...&quot;) time.Sleep(time.Second * time.Duration(5)) fmt.Println(&quot;Download successful&quot;) } func main() { fmt.Println(&quot;Main begins...&quot;) go download() time.Sleep(time.Second * time.Duration(6)) fmt.Println(&quot;Main end&quot;) } /* Main begins... Download begins... Download successful Main end */ 可以看到这里子协程是已经正常运行了的。但是，我们以后所有的程序都需要使用 sleep 函数来阻塞么？这显然是不合理的，因此，go 提供了一些其他的方法 比如使用sync方式 package main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup func download() { fmt.Println(&quot;Download begins...&quot;) time.Sleep(time.Second * time.Duration(5)) fmt.Println(&quot;Download successful&quot;) wg.Done() } func main() { wg.Add(1) fmt.Println(&quot;Main begins...&quot;) go download() wg.Wait() fmt.Println(&quot;Main end&quot;) } 这种方式要求所有的子协程之间没有通信，主协程会一直阻塞，直到所有的子协程都结束 那么，如果我们的子协程之间需要通信呢？是的，go 也提供了通道（channel）的方式来解决这个问题 package main import ( &quot;fmt&quot; &quot;time&quot; ) var ch = make(chan string, 10) func download() { fmt.Println(&quot;Download begins...&quot;) sleepTime := time.Second * time.Duration(5) time.Sleep(sleepTime) fmt.Println(&quot;Download successful&quot;) ch &lt;- sleepTime.String() } func main() { fmt.Println(&quot;Main begins...&quot;) go download() go download() go download() for i := 0; i &lt; 3; i++ { msg := &lt;-ch fmt.Println(msg) } fmt.Println(&quot;Main end&quot;) } 通道依然会阻塞主协程，等待子协程的结束，但是允许协程之间的数据交换 ","link":"https://zhx6.github.io/Z4iuFcxwS/"},{"title":"Go 学习笔记：接口","content":"与常规的面向对象语言不同，这门语言没有提供类（class）和继承这种东西。相对的，go 提供了接口（interface）这种类型来解决这些问题 接口是一组 method 的集合，做的事情就是定义一个协议，但是你不需要去实现它 这里给出了利用接口编程的样例： package main import ( &quot;fmt&quot; ) type Animal interface { Bark() } func (dog Dog) Bark() { fmt.Println(&quot;I am&quot;, dog.name, &quot;I can bark!&quot;) } func (cat Cat) Bark() { fmt.Println(&quot;I am&quot;, cat.name, &quot;I can't bark!&quot;) } type Dog struct { name string } type Cat struct { name string } func main() { var animal Animal animal = Dog{&quot;yiqi&quot;} animal.Bark() animal = Cat{&quot;Tom&quot;} animal.Bark() } ","link":"https://zhx6.github.io/OQvYPycQm/"},{"title":"Go 学习笔记：集合 map 与范围 range","content":"集合 range Go 语言同时支持了集合这种东西，它是一种无序的键值对的集合，可以通过 key 来快速检索数据，也可以像切片或者数组那样被迭代。不过集合是无序的，我们无法确定他的返回顺序，因为他是基于 hash 表实现的 package main import ( &quot;fmt&quot; ) func main() { trans := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} fmt.Println(trans[&quot;one&quot;]) fmt.Println(trans[&quot;two&quot;]) fmt.Println(trans[&quot;three&quot;]) trans[&quot;four&quot;] = 4 fmt.Println(trans[&quot;four&quot;]) } 如果想要删除集合也是非常简单的，go 提供了 delete 函数 package main import ( &quot;fmt&quot; ) func main() { trans := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} fmt.Println(trans[&quot;one&quot;]) fmt.Println(trans[&quot;two&quot;]) fmt.Println(trans[&quot;three&quot;]) trans[&quot;four&quot;] = 4 fmt.Println(trans[&quot;four&quot;]) delete(trans, &quot;four&quot;) fmt.Println(trans[&quot;four&quot;]) } 范围 range range 关键字是用来在 for 循环中迭代数组、切片、通道或集合的元素的东西，在数组和切片中，它返回元素的索引和索引对应的值，在集合中返回 key-value 对 遍历切片 package main import ( &quot;fmt&quot; ) func main() { slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} var sum int = 0 for idx, i := range slice { sum += i fmt.Println(&quot;idx:&quot;, idx) } fmt.Println(sum) } 遍历数组 package main import ( &quot;fmt&quot; ) func main() { slice := [20]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} var sum int = 0 for idx, i := range slice { sum += i fmt.Println(&quot;idx:&quot;, idx) } fmt.Println(sum) } 遍历集合 package main import ( &quot;fmt&quot; ) func main() { trans := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} // fmt.Println(trans[&quot;one&quot;]) for key, value := range trans { fmt.Println(key, value) } trans[&quot;four&quot;] = 4 for key, value := range trans { fmt.Println(key, value) } } ","link":"https://zhx6.github.io/b-3WW6Usb/"},{"title":"Go 学习笔记：切片 slice","content":"在 Go 中，因为数组的长度是不可变的，这就会导致在某些场景中的尴尬场面。因此，go 提供了一种 “动态数组”——slice，这种类型长度不固定，可以扩容。具体可以参考 Python 的” 列表 “，不过他俩还是区别蛮大的 首先我们可以创建一个切片 package main import ( &quot;fmt&quot; ) func main() { slice1 := make([]int, 20, 30) // 类型、切片长度、预留长度(可选) fmt.Println(slice1) fmt.Printf(&quot;%T\\n&quot;, slice1) // []int } make 函数是用来为 slice map channel 分配内存的。当然，除了 make 函数以外，还有其他的方式 package main import ( &quot;fmt&quot; ) func main() { slice1 := []int{1, 2, 3} fmt.Println(slice1) fmt.Printf(&quot;%T\\n&quot;, slice1) // []int } 切片也可以利用数组初始化 package main import ( &quot;fmt&quot; ) func main() { array := [5]int{1, 2, 3, 4, 5} slice1 := array[:] fmt.Println(slice1) fmt.Println(array) fmt.Printf(&quot;%T\\n&quot;, slice1) fmt.Printf(&quot;%T\\n&quot;, array) } 我们也可以不引用完 package main import ( &quot;fmt&quot; ) func main() { array := [5]int{1, 2, 3, 4, 5} slice1 := array[0:2] // [1 2], 取左闭右开的一个区间 fmt.Println(slice1) fmt.Println(array) fmt.Printf(&quot;%T\\n&quot;, slice1) fmt.Printf(&quot;%T\\n&quot;, array) } 当然，go 提供了两个函数，用来获取 slice 的长度与切片最大长度 package main import ( &quot;fmt&quot; ) func main() { slice := make([]int, 5, 10) fmt.Println(len(slice), cap(slice)) // 5, 10 } slice 也可以像 Python 的列表一样切片 package main import ( &quot;fmt&quot; ) func main() { slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} fmt.Println(slice[0:5]) fmt.Println(slice[:]) fmt.Println(slice[:5]) fmt.Println(slice[2:]) } 如果想要拓展切片的空间，可以使用append和copy函数 package main import ( &quot;fmt&quot; ) func main() { slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} fmt.Println(len(slice), cap(slice)) slice = append(slice, 11) // 在最后面追加元素 fmt.Println(len(slice), cap(slice)) // 追加后，预留的空间翻倍了 fmt.Println(slice) } copy 函数可以帮助你将一个小的切片复制到另一个大的切片中去 package main import ( &quot;fmt&quot; ) func main() { slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} slice1 := make([]int, 11, 22) copy(slice1, slice) fmt.Println(slice, cap(slice)) fmt.Println(slice1, cap(slice1)) fmt.Println(slice) fmt.Println(slice1) } ","link":"https://zhx6.github.io/flEob5eRz/"},{"title":"Go 学习笔记：结构体","content":"go 也提供了结构体这个功能，具体实现也很类似与 C 语言 声明结构体 package main import ( &quot;fmt&quot; ) type character struct { name string star int } func main() { var ch1 character = character{name: &quot;shenli&quot;, star: 5} ch2 := character{&quot;leidian&quot;, 5} fmt.Println(ch1) fmt.Println(ch2) } 亦或者是访问里面的成员变量 package main import ( &quot;fmt&quot; ) type character struct { name string star int } func main() { var ch1 character = character{name: &quot;shenli&quot;, star: 5} ch2 := character{&quot;leidian&quot;, 5} fmt.Println(ch1.name) fmt.Println(ch1.star) fmt.Println(ch1.name) fmt.Println(ch2.star) } 当然，也可以作为参数传入函数内 package main import ( &quot;fmt&quot; ) type character struct { name string star int } func main() { var ch1 character = character{name: &quot;shenli&quot;, star: 5} ch2 := character{&quot;leidian&quot;, 5} getInfo(ch1) getInfo(ch2) } func getInfo(ch character) { fmt.Println(ch.name) fmt.Println(ch.star) } 学了结构体，简单写一个单向链表 package main import ( &quot;fmt&quot; ) type node struct { value int next *node } type linkList struct { length int next *node tail *node } func main() { list := createLinkList() createNode(list, 2) createNode(list, 3) createNode(list, 7) forEach(*list) } func createLinkList() *linkList { return &amp;linkList{length: 0} } func createNode(curLinkList *linkList, value int) int { tail := curLinkList.tail newNode := &amp;node{value: value} length := curLinkList.length + 1 if tail == nil { curLinkList.tail = newNode curLinkList.next = newNode } else { curNode := curLinkList.tail curLinkList.tail = newNode curNode.next = newNode } curLinkList.length = length return length } func forEach(curLinkList linkList) int { curNode := curLinkList.next fmt.Println(curNode.value) for curNode.next != nil { curNode = curNode.next fmt.Println(curNode.value) } return curLinkList.length } ","link":"https://zhx6.github.io/dck1-G09H/"},{"title":"Go 学习笔记：指针","content":"与 C 语言相同，go 也是提供了指针支持的 package main import ( &quot;fmt&quot; ) func main() { var p *int var n int = 12 p = &amp;n fmt.Printf(&quot;%x\\n%x\\n&quot;, p, &amp;n) fmt.Printf(&quot;%d\\n%d\\n&quot;, *p, n) } 如果不对指针赋值，那么他的值就会使 nil，使用%x输出出来就是0 package main import ( &quot;fmt&quot; ) func main() { var p *int fmt.Printf(&quot;%x\\n&quot;, p) fmt.Println(p) } 当然，你也可以将 C 语言的数组指针挪用到 go 里来 package main import ( &quot;fmt&quot; ) func main() { var array = [3]int{1, 3, 6} var p *[3]int = &amp;array // 数组指针 for _, i := range *p { fmt.Println(i) } } 指针数组也是同理 package main import ( &quot;fmt&quot; ) func main() { var array = [3]int{1, 3, 6} var p [3]*int // 指针数组 for idx, _ := range array { p[idx] = &amp;array[idx] } for _, item := range p { fmt.Println(*item) } } 还有指向指针的指针 package main import ( &quot;fmt&quot; ) func main() { var value int = 12 var p *int = &amp;value var pp **int = &amp;p fmt.Println(value) fmt.Println(p, *p, &amp;p) fmt.Println(pp, *pp, **pp) } ","link":"https://zhx6.github.io/HyRGY_9v5/"},{"title":"Go 学习笔记：函数","content":"函数 在 Go 语言中，至少会有一个 main 函数，作为执行的入口，那我们如果需要自定义函数怎么写呢？ 我们先来写一个判断最大值的函数 package main import ( &quot;fmt&quot; ) func main() { a, b := 12, 34 fmt.Println(max(a, b)) } func max(a, b int) int { if a &gt;= b { return a } else { return b } } 当然，Go 也和 Python 一样，支持多个函数返回值 package main import ( &quot;fmt&quot; &quot;math&quot; ) func main() { array := [...]int{1, 2, 3, 4, 5, 6} fmt.Println(max_min(array[:])) } func max_min(array []int) (int, int) { maxNum, minNum := 0, math.MaxInt32 for _, i := range array { if maxNum &lt; i { maxNum = i } if minNum &gt; i { minNum = i } } return maxNum, minNum } 当然，你也可以参考 Javascript 的新建函数的方法 package main import ( &quot;fmt&quot; &quot;math&quot; ) func main() { array := [...]int{1, 2, 3, 4, 5, 6} max_min := func(array []int) (int, int) { maxNum, minNum := 0, math.MaxInt32 for _, i := range array { if maxNum &lt; i { maxNum = i } if minNum &gt; i { minNum = i } } return maxNum, minNum } fmt.Println(max_min(array[:])) } 不过比较糟糕的是，这个愚蠢的语言似乎没有支持重载，尽管 Python 和 Javascript 也不支持，但是后面这俩是动态语言啊！！！你一个静态的语言不支持重载真的好么？？？ 因为不支持重载，这也导致了math.Max()只能支持 float64 类型的参数 package main import ( &quot;fmt&quot; ) func main() { a, b := 1, 2 fmt.Println(max(a, b)) } func max(a, b int) int { if a &gt; b { return a } else { return b } } func max(a, b float64) float64 { if a &gt; b { return a } else { return b } } /* # command-line-arguments .\\main.go:16:17: cannot use a (type int) as type float64 in argument to max .\\main.go:16:17: cannot use b (type int) as type float64 in argument to max .\\main.go:27:6: max redeclared in this block previous declaration at .\\main.go:19:20 */ 顺便一提，Go 是支持回调函数的 package main import ( &quot;fmt&quot; ) func main() { process(callback) } func callback() { fmt.Println(&quot;Finished&quot;) } func process(function func()) { fmt.Println(&quot;Processing&quot;) function() } 变量作用域 golang 中的作用域与 C 语言相同 局部变量和全局变量 package main import ( &quot;fmt&quot; ) var GLOBAL int = 77 func main() { var a, b, c int a, b, c = 1, 2, 3 fmt.Println(a, b, c, GLOBAL) // a, b, c 是局部变量 // GLOBAL 是全局变量 } 还有形式参数 package main import ( &quot;fmt&quot; ) var a, b int = 10, 20 func main() { fmt.Println(1, 2) } func sum(a, b int) int { fmt.Println(a, b) return a + b } ","link":"https://zhx6.github.io/CN8d585fb/"},{"title":"Go 学习笔记：运算符","content":"Go 学习笔记：运算符 Go 支持的运算符和 C 语言是完全相同的 比如基础的四则运算 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 5, 7 fmt.Println(a + b) fmt.Println(a - b) fmt.Println(a * b) fmt.Println(a / b) fmt.Println(a % b) } 当然还有自增自减 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 5, 7 a++ fmt.Println(a) b-- fmt.Println(b) } 但是与 C 语言不同的是，自增自减只有a++的形式，++a的形式是不被允许的，同时，你必须要将其作为独立的语句使用 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 5, 7 fmt.Println(a++) // 需要作为独立的语句使用 fmt.Println(--b) // 这种形式也是不被允许的 } 当然，C 语言常用的关系运算符也是支持的 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 5, 7 fmt.Println(a == b) fmt.Println(a &gt;= b) fmt.Println(a &lt;= b) fmt.Println(a != b) fmt.Println(a &gt; b) fmt.Println(a &lt; b) } 还有逻辑运算符 package main import ( &quot;fmt&quot; ) func main() { var a, b bool = true, false fmt.Println(a &amp;&amp; b) fmt.Println(a || b) fmt.Println(a &amp;&amp; !b) } 值得注意的是，逻辑运算符两边都只能值bool类型的值，使用非布尔类型的值是会报错的 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 1, 2 fmt.Println(a &amp;&amp; b) fmt.Println(a || b) fmt.Println(a &amp;&amp; !b) } /* # command-line-arguments .\\main.go:16:16: invalid operation: a &amp;&amp; b (operator &amp;&amp; not defined on int) .\\main.go:17:16: invalid operation: a || b (operator || not defined on int) .\\main.go:18:19: invalid operation: !b (operator ! not defined on int) */ 同时，位运算也是可以的 package main import ( &quot;fmt&quot; ) func main() { var a, b int = 1, 2 fmt.Println(a &lt;&lt; 1) // 二进制左移一位 fmt.Println(b &gt;&gt; 1) // 二进制右移一位 fmt.Println(a | 1) // 求或 fmt.Println(a &amp; 1) // 求与 fmt.Println(a ^ 1) // 求异或 } 当然还有一些赋值符号 package main import ( &quot;fmt&quot; ) func main() { var a, b, tmp int = 2, 4, 0 tmp = a a = b b = tmp fmt.Println(a, b, tmp) a -= tmp fmt.Println(a) a += tmp fmt.Println(a) a *= tmp fmt.Println(a) a /= tmp fmt.Println(a) a &lt;&lt;= tmp fmt.Println(a) a &gt;&gt;= tmp fmt.Println(a) a ^= tmp fmt.Println(a) a |= tmp fmt.Println(a) a &amp;= tmp fmt.Println(a) } 还有俩和指针相关的 package main import ( &quot;fmt&quot; ) func main() { var a *int // * 表示这是一个指针变量 var b int = 12 a = &amp;b // &amp; 取地址符 fmt.Println(*a, a, b) } 运算优先级也可以直接参考 C 语言 优先级 运算符 5 * / % &lt;&lt; &gt;&gt; &amp; &amp; ^ 4 + - | ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 || ","link":"https://zhx6.github.io/Z-j6SZGnc/"},{"title":"Go 学习笔记：循环","content":"和 Python 或 C 语言不同，Go 没有 while 循环，它使用了 for 循环来替代 while 循环（不过仔细想想，写了这么久代码，while 循环也确实不咋用） C 语言中的 for 循环转换成 go 里的就是这样 package main import ( &quot;fmt&quot; ) func main() { for i := 0; i &lt; 5; i++ { fmt.Println(&quot;Hello world&quot;) } } 当然，for 也能替代 while package main import ( &quot;fmt&quot; ) func main() { num := 5 for num != 0 { fmt.Println(&quot;Hello world&quot;) num-- } } 当然也可以写成死循环 package main import ( &quot;fmt&quot; ) func main() { for { fmt.Println(&quot;Hello world&quot;) } } 你也可以用 range 来对可迭代对象循环 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot;} for idx, item := range strs { fmt.Println(idx, item) } } 当然 for 也是可以嵌套的 package main import ( &quot;fmt&quot; ) func main() { var num = 10 for i := 1; i &lt;= num; i++ { for j := 1; j &lt;= num; j++ { fmt.Printf(&quot;%-4d&quot;, i+j-1) } fmt.Println() } } 既然谈到循环了，当然不缺break continue 和goto了 break 可用于跳出循环 package main import ( &quot;fmt&quot; ) func main() { var num = 10 var end = 0 for i := 1; i &lt;= num; i++ { if i &gt;= 5 { fmt.Println(i) end = i break } } fmt.Println(end) // end = 5 } 也可以跳出 switch 语句 package main import ( &quot;fmt&quot; ) func main() { var grade string = &quot;A&quot; switch grade { case &quot;A&quot;: fmt.Println(&quot;优秀&quot;) break fmt.Println(&quot;优秀1&quot;) // 这段就不会执行了 case &quot;B&quot;: fmt.Println(&quot;良好&quot;) case &quot;C&quot;: fmt.Println(&quot;中等&quot;) default: fmt.Println(&quot;不及格&quot;) } } 也可以使用标号跳出多重循环 package main import ( &quot;fmt&quot; ) func main() { var num = 10 re: for i := 1; i &lt;= num; i++ { for j := 1; j &lt;= num; j++ { if i &gt; num/2 { break re } fmt.Printf(&quot;%-4d&quot;, i+j-1) } fmt.Println() } } continue 可用于跳过本次循环 package main import ( &quot;fmt&quot; ) func main() { var num = 10 var end = 0 for i := 1; i &lt;= num; i++ { if i &gt;= 5 { fmt.Println(i) end = i continue } } fmt.Println(end) // end = 10 } 同样的，continue 也支持使用标签，但是这里就不演示了，具体可以参考：Go 语言 continue 语句 | 菜鸟教程 (runoob.com) goto 又是这个鸡肋的功能... 这个可以配合标签实现无条件的跳转，但是常常会造成程序流程的混乱，使程序的理解和调试都产生困难，因此本文不做讲解，具体可以参考Go 语言 goto 语句 | 菜鸟教程 (runoob.com) ","link":"https://zhx6.github.io/uCYjwvEs-/"},{"title":"Go 学习笔记：条件语句","content":"Go 语言提供了多种条件语句，比如if if...else switch select(待补充) 1.if &amp;&amp; if...else 这俩和 C 语言中的大致相同，最大的不同可能就是 if 后面不加括号了吧 package main import ( &quot;fmt&quot; ) func main() { var array = [10]int{2: 1, 4: 1, 6: 1} for _, i := range array { // fmt.Println() if i == 1 { fmt.Println(&quot;YES&quot;) } else { fmt.Println(&quot;NO&quot;) } } } 2.switch 语句 这个 switch 语句，参照着 C 语言还是挺好理解的，不过这个 case 后面不用打大括号这个，倒是挺有 Python 那味儿了 package main import ( &quot;fmt&quot; ) func main() { var grade string = &quot;A&quot; switch grade { case &quot;A&quot;: fmt.Println(&quot;优秀&quot;) fmt.Println(&quot;优秀1&quot;) case &quot;B&quot;: fmt.Println(&quot;良好&quot;) case &quot;C&quot;: fmt.Println(&quot;中等&quot;) default: fmt.Println(&quot;不及格&quot;) } } 还有一种写法 package main import ( &quot;fmt&quot; ) func main() { var grade string = &quot;A&quot; switch { case grade == &quot;A&quot;: fmt.Println(&quot;优秀&quot;) fmt.Println(&quot;优秀1&quot;) case grade == &quot;B&quot;: fmt.Println(&quot;良好&quot;) case grade == &quot;C&quot;: fmt.Println(&quot;中等&quot;) default: fmt.Println(&quot;不及格&quot;) } } 3.Type switch 这个 switch 就不是用来判断值的了，而是用来判断数据类型的 package main import ( &quot;fmt&quot; ) func main() { var grade interface{} grade = &quot;A&quot; switch grade.(type) { case nil: fmt.Println(&quot;nil&quot;) case float32: fmt.Println(&quot;float32&quot;) case string: fmt.Println(&quot;string&quot;) case bool, int: fmt.Println(&quot;bool 或 int&quot;) default: fmt.Println(&quot;我管他是什么类型&quot;) } } 4.fallthrough 使用 fallthrough 的 switch 语句会强制执行下一个 case 而不会去判断是否条件为 true 仅支持下方这种例子，不过这玩意儿基本上不咋用就对了 package main import ( &quot;fmt&quot; ) func main() { var grade string = &quot;A&quot; switch { case grade == &quot;A&quot;: fmt.Println(&quot;优秀&quot;) fmt.Println(&quot;优秀1&quot;) fallthrough case grade == &quot;B&quot;: fmt.Println(&quot;良好&quot;) case grade == &quot;C&quot;: fmt.Println(&quot;中等&quot;) default: fmt.Println(&quot;不及格&quot;) } } ","link":"https://zhx6.github.io/wQJGBq3bU/"},{"title":"Go 学习笔记：数组","content":"Golang 是支持了数组这种数据结构的，具体可以参考 C 语言里的数组 比如我们想要申请一个新的数组 package main import ( &quot;fmt&quot; ) func main() { var strs [20]string // 声明一个20个长度的字符串数组 fmt.Println(strs) } 当然也可以这样 package main import ( &quot;fmt&quot; ) func main() { strs := [20]string{} fmt.Println(strs) } 当你不知道这个数组需要声明多大的时候，可以这样写，Go 会自动判断数组的大小 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot;} fmt.Println(strs, len(strs)) // [Hello world my dear] 4 } 当然，你也可以这样写 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, 7: &quot;dear&quot;} fmt.Println(strs, len(strs)) // [Hello world my dear] 8 } 上述的写法代表下标为 7 的位置是”dear“ 通过下标访问数组的方式也和 C 语言相似 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot;} fmt.Println(strs[1]) } 如果说他跟 C 语言很相似，那我倒是觉得遍历他的时候和 Python 有点串味 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot;} for i := 0; i &lt; len(strs); i++ { fmt.Println(strs[i]) } } 或许你也可以用 range 来遍历 package main import ( &quot;fmt&quot; ) func main() { strs := [...]string{&quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot;} for idx, item := range strs { fmt.Println(item, idx) } // 第一个是索引，第二个是内容 } ","link":"https://zhx6.github.io/bm9uElgSK/"},{"title":"Go 学习笔记：数据类型 ","content":"数据类型 Golang 支持多种数据类型，包括布尔型，int， float（float32， float64），字符串类型，还有一系列的派生类型 Golang 没有 long long 和 double 类型，取而代之的是（int64 和 float64） package main import ( &quot;fmt&quot; ) func main() { var intNum int var float32Num float32 var float64Num float64 var boolNum bool var str string fmt.Println( intNum, float32Num, float64Num, boolNum, str) // 声明后不使用会编译错误 } 变量声明 Golang 有多种声明变量的方法，比如： package main import ( &quot;fmt&quot; ) func main() { var s string = &quot;Hello world&quot; fmt.Println(s) } 当然，你也可以一次性申请多个变量： package main import ( &quot;fmt&quot; ) func main() { var s1, s2, s3, s4 string = &quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dear&quot; fmt.Println(s1, s2, s3, s4) } 在书写上述代码的时候，你也可以通过 Go 根据值自动判断变量类型的特性，来简写上述代码 package main import ( &quot;fmt&quot; ) func main() { var s1, s2, s3, s4 = &quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dears&quot; fmt.Println(s1, s2, s3, s4) } 除了通过var来声明变量，我们还可以使用:=来声明变量，则上面的代码会变为 package main import ( &quot;fmt&quot; ) func main() { s1, s2, s3, s4 := &quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dears&quot; // 如果左侧出现了已有的变量，则会报错 fmt.Println(s1, s2, s3, s4) } 值得注意的是，这种声明方法只能在函数体内使用 package main import ( &quot;fmt&quot; ) glb := 12 // 这样书写是错误的 func main() { fmt.Println(gbl) } 一般我们再书写全局变量的时候，是这样写的 package main import ( &quot;fmt&quot; ) var ( RED string = &quot;red&quot; GREEN string = &quot;green&quot; BLUE string = &quot;blue&quot; ) func main() { fmt.Println(RED, GREEN, BLUE) } 补充：在交换代码值的时候，可以参考 Python 的一些写法，而毋需再声明新的变量 package main import ( &quot;fmt&quot; ) func main() { var s1, s2, s3, s4 = &quot;Hello&quot;, &quot;world&quot;, &quot;my&quot;, &quot;dears&quot; s3, s4 = s4, s3 // 必须确保参与交换的变量数据类型相同 fmt.Println(s1, s2, s3, s4) } 值得注意的是，在 golang 中，string 是不可修改的，因此尝试修改字符串内部的操作是被禁止的 package main import &quot;fmt&quot; func main() { str := &quot;hello world&quot; str[0] = &quot;H&quot; // cannot assign to str[0] (strings are immutable) fmt.Println(str) } 这样的好处是，字符串类型的子字符串切片就不再需要花销额外的内存了 ","link":"https://zhx6.github.io/ekAVD-chP/"},{"title":"Go 学习笔记：输入输出 ","content":"Golang 的输入输出方式与 C 语言相似，支持的 API 大致和 C 语言相似 package main import ( &quot;fmt&quot; &quot;os&quot; ) func main() { fmt.Print(&quot;Hello world&quot;) // 原样输出 fmt.Println(&quot;Hello world&quot;) // 输出行 fmt.Printf(&quot;%s&quot;, &quot;Hello world&quot;) // 支持格式化输出 fmt.Fprint(os.Stdout, &quot;Hello world&quot;) // 指定输出对象 } 当然，想要输出到文件也是可以的 package main import ( &quot;fmt&quot; &quot;os&quot; ) func main() { file, err := os.OpenFile(&quot;./output.txt&quot;, os.O_CREATE, 0755) defer file.Close() if err != nil { fmt.Println(err) return } fmt.Fprintln(file, &quot;Hello world&quot;) } Golang 的输入也可以直接参考 C 语言的 package main import ( &quot;fmt&quot; ) func main() { var str string fmt.Scanf(&quot;%s&quot;, &amp;str) // 注意这里输入字符串的时候是需要取地址的，C语言不用 fmt.Println(str) } 同理，你也可以从文件输入 package main import ( &quot;fmt&quot; &quot;os&quot; ) func main() { file, err := os.OpenFile(&quot;./output.txt&quot;, os.O_RDONLY, 0755) defer file.Close() if err != nil { fmt.Println(err) return } var str string fmt.Fscanf(file, &quot;%s&quot;, &amp;str) // 注意这里输入字符串的时候是需要取地址的，C语言不用 fmt.Println(str) } 参考附表 整数 %b 表示为二进制 %c 该值对应的unicode码值 %d 表示为十进制 %o 表示为八进制 %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 %x 表示为十六进制，使用a-f %X 表示为十六进制，使用A-F %U 表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot; 浮点数、复数 %b 无小数部分、二进制指数的科学计数法 %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） %f: 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 %9.f 宽度9，精度0 字符串 %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f） %X 每个字节用两字符十六进制数表示（使用A-F） 指针 %p 表示为十六进制，并加上前导的0x 其他 %v 相应值的默认格式 %+v 打印结构体时，会添加字段名 ","link":"https://zhx6.github.io/a51Gqdu-o/"},{"title":"用 Alpine.js 构建一个 ajax 表单","content":"不解释Alpine.js是啥了，感兴趣的小伙伴自行百度，类似轻量Vue框架吧？这篇教程就带着大家入门一下 首先，让我们建立一个像这样的常规联系表格： 关键问题是我们如何将通过 ajax 发送数据并使用 Alpine 处理所有表单数据。 大家之前应该已经用 vanilla JS 或 jQuery 做过无数次了。常规方式必须通过引用获取所有元素，访问它们的值，然后发送数据。 Alpine可以使这项任务变得轻而易举，类似Vue和其他前端框架那样。 下面我们建立一个简单的表单（姓名、电子邮件、消息提交按钮） &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot;&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;border w-full p-1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;border w-full p-1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Message:&lt;/label&gt; &lt;textarea name=&quot;message&quot; class=&quot;border w-full p-1&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 text-white w-full p-2&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 这就是表单的基本 HTML 结构。 到目前为止，根本没有 javascript，它只是一个可以与页面重新加载一起使用的常规表单。 现在，让我们在上面撒一些 Alpine.js。 如下所示： &lt;script&gt; function contactForm() { return { formData: { name: '', email: '', message: '' }, } } &lt;/script&gt; 然后你只需要在里面添加那个函数调用x-data： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot;&gt; 现在，介绍一下x-model指令。 这个指令可以使输入元素与组件数据保持同步。 因为formData在组件范围内有对象，因此我们可以在输入和文本区域中使用它们，如下所示： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot;&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.name&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Message:&lt;/label&gt; &lt;textarea name=&quot;message&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 text-white w-full p-2&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 在vanilla JavaScript中，可能必须使用类似的内容获取元素，getElementById然后访问其值。 有了x-model，当输入input元素时，数据对象会自动更新为输入的任何内容。 现在，至于 ajax 部分，让我们只使用fetch API，因此我们不必拉外部依赖项，但您当然可以根据自己的需要进行调整： function contactForm() { return { formData: { name: '', email: '', message: '' }, message: '', submitData() { this.message = '' fetch('/contact', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.formData) }) .then(() =&gt; { this.message = 'Form sucessfully submitted!' }) .catch(() =&gt; { this.message = 'Ooops! Something went wrong!' }) } } } 并在表单结束标记之前添加此段落： &lt;p x-text=&quot;message&quot;&gt;&lt;/p&gt; 如果你不明白.thenand.catch语句是 什么 ，别担心，你可以查看这篇关于Promises 的文章。基本上，整个submitData方法将对/contact路由执行 POST 请求 ，并将表单数据作为字符串化 JSON 传递。 如果一切都成功，.then则执行块，如果响应中有错误，则执行.catch。 现在，我们必须在提交表单时调用此方法。 表单元素发出一个submit事件，所以我们可以使用x-on指令来监听它 ，因为我们不想重新加载页面，所以我们添加.prevent事件修饰符来“劫持”表单提交并使用我们自己的方法“submitData” ： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot; @submit.prevent=&quot;submitData&quot;&gt; 就是这样！ 这样就获得了一个使用 Alpine.js 构建的可工作的 ajax 表单。 我们可以再加点东西，为提交按钮添加一些动态样式以改善用户体验： 在头部添加这个样式标签（我只会添加这个样式，因为到目前为止，TailwindCSS 不支持开箱即用的禁用状态）： &lt;style&gt; button:disabled { cursor: not-allowed; opacity: 0.5; } &lt;/style&gt; 现在，用这个替换旧的提交按钮： &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 disabled:opacity-50 text-white w-full p-2 mb-4&quot; x-text=&quot;buttonLabel&quot; :disabled=&quot;loading&quot;&gt;&lt;/button&gt; 再介绍两个有趣的属性x-text指令和:disabled。我们将使用x-text来动态更改按钮的标签:disabled，并在提交表单时禁用该按钮。 contactForm使用以下内容更新函数： loading: false, buttonLabel: 'Submit', submitData() { this.buttonLabel = 'Submitting...' this.loading = true; this.message = '' fetch('/contact', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.formData) }) .then(() =&gt; { this.message = 'Form sucessfully submitted!' }) .catch(() =&gt; { this.message = 'Ooops! Something went wrong!' }) .finally(() =&gt; { this.loading = false; this.buttonLabel = 'Submit' }) } 就是这样！ ","link":"https://zhx6.github.io/aPQPd4Z5x/"},{"title":"Telnet为什么不安全","content":"简介 Telnet（Teletype Network）属于应用层，默认端口为23，是一个明文传送协议（包括用户名、密码、内容都在互联网上传送），同时分为客户端与服务端进行交互。 流程 Wireshark抓包图如下 通过分析数据包，Telnet整个流程分为四个阶段为了更好理解如下图所示 第一阶段：TCP三次握手 很显然，Telnet协议是TCP/IP协议族的一员。由客户端主动向目标服务端建立连接。（三次握手这里暂时不展开讲） 第二阶段：双方通过NVT协商 Telnet协议支持应用不同的操作系统中，并可以很好的在不同操作系统中传输命令；通俗来讲NVT起到了翻译的作用，支持异构性。协商的内容包括窗口大小、工作模式等等。 第三阶段：双通过NVT传输命令 双方协商完成后，服务端回显给客户端登录命令行，进行验证，验证通过后进行后续的命令操作。 第四阶段：撤销TCP连接 客户端对服务端进行撤销连接，此时是一个TCP链接；双方进行FIN，ACK。 数据： 由于Telnet是明文传输，很容易被抓到进行分析从而入侵主机；一旦被攻击者抓到包，这个就相当于在裸跑，毫无秘密可言。 ","link":"https://zhx6.github.io/CLWxuTMTo/"},{"title":"PHP 获取每日BING图 并且缓存URL链接到本地JSON","content":"将获取的BING图链接进行缓存，减少服务器负担，提升访问速度。 &lt;?php $filename = &quot;./cache.json&quot;; if (file_exists($filename) === false) { file_put_contents($filename, &quot;&quot;); } $handle = fopen($filename, &quot;r&quot;); $contents = fread($handle, filesize($filename)); fclose($handle); $contents = json_decode($contents, true); if (filesize($filename) === 0) { getBingImg(); } else { if ($contents['time'] === date(&quot;Ymd&quot;)) { Header(&quot;Location: &quot; . $contents['url']); } else { getBingImg(); } } function getBingImg() { $str = json_decode(file_get_contents('https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1')); if (isset($str-&gt;images[0])) { $impurely = 'https://cn.bing.com' . $str-&gt;images[0]-&gt;url; } else { $impurely = false; } if ($impurely) { global $contents; if ($contents['url'] !== $impurely) { global $filename; $data = array( &quot;time&quot; =&gt; date(&quot;Ymd&quot;), &quot;url&quot; =&gt; $impurely ); $data = json_encode($data); file_put_contents($filename, $data); } Header(&quot;Location: &quot; . $impurely); exit(); } else { exit('error'); } } ?&gt; ","link":"https://zhx6.github.io/d8K-PzlGJ/"},{"title":"添加网页动态滚动进度条|滚动指示器","content":"代码 &lt;!--动态滚动进度条--&gt; &lt;div class=&quot;scroll-line&quot; style=&quot;z-index: 999;position: fixed;height: 3px;margin-top: 0px;background-color: #6B999B;width: 0%;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(window).scroll(function() { var winTop = $(window).scrollTop(), //滚动条的位置 docHeight = $(document).height(), //文档高度 winHeight = $(window).height(); //窗口高度 var scrolled = (winTop / (docHeight - winHeight))*100; $('.scroll-line').css('width', (scrolled + '%')); }); &lt;/script&gt; ","link":"https://zhx6.github.io/lU92bYTeX/"},{"title":"Python float乘法运算小数点后会出现很多位小数问题","content":"前言 说实话 这问题挺艹蛋的，我调试了半天，发现是Python所有浮点数规范遵从IEEEE754二进制浮点数算术标准（ANSI/IEEE Std 754-1985），说一下我想实现什么吧，就是出价的数字 出价 78.6 换算成程序出价是要乘个100000 真实结果：7860000 错误代码 (78 + round(random.uniform(1, 0), 2)) * 100000 运行结果 7880000.0 7816000.0 7859000.0 7834999.999999999 7820999.999999999 7859999.999999999 这肯定不对的啊..... 后来查到一篇文章讲了这个 https://xufive.blog.csdn.net/article/details/103816159 真是太恶心了 解决方法 from decimal import * Decimal((78 + round(random.uniform(1, 0), 2)) * 100000).quantize(Decimal('0')) 用了Decimal模块完美解决此问题 结果 7844000 7898000 7900000 7825000 7872000 7843000 7810000 7866000 7807000 7836000 7826000 7803000 7832000 7868000 7851000 7868000 ","link":"https://zhx6.github.io/A88jsrz2/"},{"title":"国内开源镜像站点汇总","content":"站点版 企业站 搜狐：http://mirrors.sohu.com/ 腾讯：https://mirrors.cloud.tencent.com/ 网易：http://mirrors.163.com/ 阿里：http://mirrors.aliyun.com/ 华为：https://mirrors.huaweicloud.com/ 教育站 上海交通大学：http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问） 华中科技大学：http://mirror.hust.edu.cn/（当前已用容量估计：4.83T） 清华大学：http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T） 北京理工大学：http://mirror.bit.edu.cn/web/ 兰州大学：http://mirror.lzu.edu.cn/ 中国科技大学：http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T） 大连东软信息学院：http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T） 东北大学：http://mirror.neu.edu.cn/ 大连理工大学：http://mirror.dlut.edu.cn/ 哈尔滨工业大学：http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问） 北京交通大学：http://mirror.bjtu.edu.cn/cn/ 中国地质大学：http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T） 浙江大学：http://mirrors.zju.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 中山大学：http://mirror.sysu.edu.cn/ 重庆大学：http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T） 北京化工大学：http://ubuntu.buct.edu.cn/（AndroidSDK镜像仅供校内使用，当前已用容量估计：1.72T） 南阳理工学院：http://mirror.nyist.edu.cn/ 中国科学院：http://www.opencas.org/mirrors/ 电子科技大学星辰工作室：http://mirrors.stuhome.net/（当前已用容量估计：1.08T） 西北农林科技大学：http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB） 其他站 首都在线科技股份有限公司（英文名CapitalOnlineDataService）：http://mirrors.yun-idc.com/ 常州贝特康姆软件技术有限公司：http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB） 公云PubYun（母公司为贝特康姆）：http://mirrors.pubyun.com/ 中国互联网络信息中心：http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB） 软件版 操作系统类 Ubuntu 阿里云：http://mirrors.aliyun.com/ubuntu-releases/ 网易：http://mirrors.163.com/ubuntu-releases/ 搜狐：http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了） 首都在线科技股份有限公司：http://mirrors.yun-idc.com/ubuntu-releases/ CentOS 网易：http://mirrors.163.com/centos/ 搜狐：http://mirrors.sohu.com/centos/ 阿里云：http://mirrors.aliyun.com/centos/ Tomcat、Apache 中国互联网络信息中心：http://mirrors.cnnic.cn/apache/ 华中科技大学：http://mirrors.hust.edu.cn/apache/ MySQL 搜狐：http://mirrors.sohu.com/mysql 中国科技技术大学：http://mirrors.ustc.edu.cn/mysql-ftp/Downloads PostgreSQL 浙江大学：http://mirrors.zju.edu.cn/postgresql/ MariaDB 中国科技技术大学：https://mirrors.ustc.edu.cn/mariadb/ VideoLAN 大连东软信息学院：http://mirrors.neusoft.edu.cn/videolan/ 中国科技大学：http://mirrors.ustc.edu.cn/videolan-ftp/ 开发工具类 Eclipse 中国科技大学：http://mirrors.ustc.edu.cn/eclipse/ 东北大学B：http://mirror.neu.edu.cn/eclipse/ 官方镜像列表状态地址 CentOS：http://mirror-status.centos.org/#cn Archlinux：https://www.archlinux.org/mirrors/status/ Ubuntu：https://launchpad.net/ubuntu/+cdmirrors Debian：http://mirror.debian.org/status.html FedoraLinux/FedoraEPEL：https://admin.fedoraproject.org/mirrormanager/mirrors Apache：http://www.apache.org/mirrors/#cn Cygwin：https://www.cygwin.com/mirrors.html ","link":"https://zhx6.github.io/HS8j95/"},{"title":"Python在Linux后台运行","content":"前言 写了一个python任务脚本，需要一直运行，刚开始使用了宝塔应用管理器和python管理器，都会出现运行着就停止运行的情况，而且上面还是显示在运行着....于是打算直接使用nohup运行 方法 先进入脚本文件的根目录 cd /www/Python/Auto/qianchuan/jiankong 使用nohup运行 nohup python -u main.py &gt; message.log 2&gt;&amp;1 &amp; 解释 nohup 和 &amp; 的区别 &amp; 是指在后台运行，但当用户退出(挂起)的时候，命令自动也跟着退出 nohup 运行 nohup --help Run COMMAND, ignoring hangup signals. 可以看到是“运行命令，忽略挂起信号”就是不挂断的运行，注意没有后台运行功能。 那么，我们可以巧妙的吧他们结合起来用就是 nohup COMMAND &amp; 这样就能使命令永久的在后台执行 -u python的输出进行了缓冲，导致message.log并不能够马上看到输出。 为python添加-u 参数，使得python不启用缓冲。 message.log 如果不填写的话，系统默认是写入到运行文件同位置output.out文件内，填写的话则会重定向到指定的文件 2&gt;&amp;1 0 表示stdin标准输入，用户键盘输入的内容 1 表示stdout标准输出，输出到显示屏的内容 2 表示stderr标准错误，报错内容 2&gt;&amp;1是一个整体，&gt;左右不能有空格，即将错误内容重定向输入到标准输出中去。 2&gt;&amp;1中的&amp;是为了区别文件1和1(标准输出)，假如为2&gt;1，就成了将错误内容输出到文件1中，而不是标准输出中。 其他 挂起后台进程以后想查看是否运行或者关闭该怎么办呢？别急，我们继续。 查看进程 ps aux | grep main.py main.py 是运行的文件 可以看到PID是12526 关闭进程 kill -9 12526 实时追踪文件输出到屏幕 tailf message.log ","link":"https://zhx6.github.io/python-zai-linux-hou-tai-yun-xing/"}]}