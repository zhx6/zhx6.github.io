{"posts":[{"title":"用 Alpine.js 构建一个 ajax 表单","content":"不解释Alpine.js是啥了，感兴趣的小伙伴自行百度，类似轻量Vue框架吧？这篇教程就带着大家入门一下 首先，让我们建立一个像这样的常规联系表格： 关键问题是我们如何将通过 ajax 发送数据并使用 Alpine 处理所有表单数据。 大家之前应该已经用 vanilla JS 或 jQuery 做过无数次了。常规方式必须通过引用获取所有元素，访问它们的值，然后发送数据。 Alpine可以使这项任务变得轻而易举，类似Vue和其他前端框架那样。 下面我们建立一个简单的表单（姓名、电子邮件、消息提交按钮） &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot;&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;border w-full p-1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;border w-full p-1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Message:&lt;/label&gt; &lt;textarea name=&quot;message&quot; class=&quot;border w-full p-1&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 text-white w-full p-2&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 这就是表单的基本 HTML 结构。 到目前为止，根本没有 javascript，它只是一个可以与页面重新加载一起使用的常规表单。 现在，让我们在上面撒一些 Alpine.js。 如下所示： &lt;script&gt; function contactForm() { return { formData: { name: '', email: '', message: '' }, } } &lt;/script&gt; 然后你只需要在里面添加那个函数调用x-data： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot;&gt; 现在，介绍一下x-model指令。 这个指令可以使输入元素与组件数据保持同步。 因为formData在组件范围内有对象，因此我们可以在输入和文本区域中使用它们，如下所示： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot;&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.name&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt; &lt;label class=&quot;block mb-2&quot;&gt;Message:&lt;/label&gt; &lt;textarea name=&quot;message&quot; class=&quot;border w-full p-1&quot; x-model=&quot;formData.message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 text-white w-full p-2&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; 在vanilla JavaScript中，可能必须使用类似的内容获取元素，getElementById然后访问其值。 有了x-model，当输入input元素时，数据对象会自动更新为输入的任何内容。 现在，至于 ajax 部分，让我们只使用fetch API，因此我们不必拉外部依赖项，但您当然可以根据自己的需要进行调整： function contactForm() { return { formData: { name: '', email: '', message: '' }, message: '', submitData() { this.message = '' fetch('/contact', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.formData) }) .then(() =&gt; { this.message = 'Form sucessfully submitted!' }) .catch(() =&gt; { this.message = 'Ooops! Something went wrong!' }) } } } 并在表单结束标记之前添加此段落： &lt;p x-text=&quot;message&quot;&gt;&lt;/p&gt; 如果你不明白.thenand.catch语句是 什么 ，别担心，你可以查看这篇关于Promises 的文章。基本上，整个submitData方法将对/contact路由执行 POST 请求 ，并将表单数据作为字符串化 JSON 传递。 如果一切都成功，.then则执行块，如果响应中有错误，则执行.catch。 现在，我们必须在提交表单时调用此方法。 表单元素发出一个submit事件，所以我们可以使用x-on指令来监听它 ，因为我们不想重新加载页面，所以我们添加.prevent事件修饰符来“劫持”表单提交并使用我们自己的方法“submitData” ： &lt;form action=&quot;/contact&quot; method=&quot;POST&quot; class=&quot;w-64 mx-auto&quot; x-data=&quot;contactForm()&quot; @submit.prevent=&quot;submitData&quot;&gt; 就是这样！ 这样就获得了一个使用 Alpine.js 构建的可工作的 ajax 表单。 我们可以再加点东西，为提交按钮添加一些动态样式以改善用户体验： 在头部添加这个样式标签（我只会添加这个样式，因为到目前为止，TailwindCSS 不支持开箱即用的禁用状态）： &lt;style&gt; button:disabled { cursor: not-allowed; opacity: 0.5; } &lt;/style&gt; 现在，用这个替换旧的提交按钮： &lt;button class=&quot;bg-gray-700 hover:bg-gray-800 disabled:opacity-50 text-white w-full p-2 mb-4&quot; x-text=&quot;buttonLabel&quot; :disabled=&quot;loading&quot;&gt;&lt;/button&gt; 再介绍两个有趣的属性x-text指令和:disabled。我们将使用x-text来动态更改按钮的标签:disabled，并在提交表单时禁用该按钮。 contactForm使用以下内容更新函数： loading: false, buttonLabel: 'Submit', submitData() { this.buttonLabel = 'Submitting...' this.loading = true; this.message = '' fetch('/contact', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.formData) }) .then(() =&gt; { this.message = 'Form sucessfully submitted!' }) .catch(() =&gt; { this.message = 'Ooops! Something went wrong!' }) .finally(() =&gt; { this.loading = false; this.buttonLabel = 'Submit' }) } 就是这样！ ","link":"https://zhx6.github.io/aPQPd4Z5x/"},{"title":"Telnet为什么不安全","content":"简介 Telnet（Teletype Network）属于应用层，默认端口为23，是一个明文传送协议（包括用户名、密码、内容都在互联网上传送），同时分为客户端与服务端进行交互。 流程 Wireshark抓包图如下 通过分析数据包，Telnet整个流程分为四个阶段为了更好理解如下图所示 第一阶段：TCP三次握手 很显然，Telnet协议是TCP/IP协议族的一员。由客户端主动向目标服务端建立连接。（三次握手这里暂时不展开讲） 第二阶段：双方通过NVT协商 Telnet协议支持应用不同的操作系统中，并可以很好的在不同操作系统中传输命令；通俗来讲NVT起到了翻译的作用，支持异构性。协商的内容包括窗口大小、工作模式等等。 第三阶段：双通过NVT传输命令 双方协商完成后，服务端回显给客户端登录命令行，进行验证，验证通过后进行后续的命令操作。 第四阶段：撤销TCP连接 客户端对服务端进行撤销连接，此时是一个TCP链接；双方进行FIN，ACK。 数据： 由于Telnet是明文传输，很容易被抓到进行分析从而入侵主机；一旦被攻击者抓到包，这个就相当于在裸跑，毫无秘密可言。 ","link":"https://zhx6.github.io/CLWxuTMTo/"},{"title":"PHP 获取每日BING图 并且缓存URL链接到本地JSON","content":"将获取的BING图链接进行缓存，减少服务器负担，提升访问速度。 &lt;?php $filename = &quot;./cache.json&quot;; if (file_exists($filename) === false) { file_put_contents($filename, &quot;&quot;); } $handle = fopen($filename, &quot;r&quot;); $contents = fread($handle, filesize($filename)); fclose($handle); $contents = json_decode($contents, true); if (filesize($filename) === 0) { getBingImg(); } else { if ($contents['time'] === date(&quot;Ymd&quot;)) { Header(&quot;Location: &quot; . $contents['url']); } else { getBingImg(); } } function getBingImg() { $str = json_decode(file_get_contents('https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1')); if (isset($str-&gt;images[0])) { $impurely = 'https://cn.bing.com' . $str-&gt;images[0]-&gt;url; } else { $impurely = false; } if ($impurely) { global $contents; if ($contents['url'] !== $impurely) { global $filename; $data = array( &quot;time&quot; =&gt; date(&quot;Ymd&quot;), &quot;url&quot; =&gt; $impurely ); $data = json_encode($data); file_put_contents($filename, $data); } Header(&quot;Location: &quot; . $impurely); exit(); } else { exit('error'); } } ?&gt; ","link":"https://zhx6.github.io/d8K-PzlGJ/"},{"title":"添加网页动态滚动进度条|滚动指示器","content":"代码 &lt;!--动态滚动进度条--&gt; &lt;div class=&quot;scroll-line&quot; style=&quot;z-index: 999;position: fixed;height: 3px;margin-top: 0px;background-color: #6B999B;width: 0%;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(window).scroll(function() { var winTop = $(window).scrollTop(), //滚动条的位置 docHeight = $(document).height(), //文档高度 winHeight = $(window).height(); //窗口高度 var scrolled = (winTop / (docHeight - winHeight))*100; $('.scroll-line').css('width', (scrolled + '%')); }); &lt;/script&gt; ","link":"https://zhx6.github.io/lU92bYTeX/"},{"title":"Python float乘法运算小数点后会出现很多位小数问题","content":"前言 说实话 这问题挺艹蛋的，我调试了半天，发现是Python所有浮点数规范遵从IEEEE754二进制浮点数算术标准（ANSI/IEEE Std 754-1985），说一下我想实现什么吧，就是出价的数字 出价 78.6 换算成程序出价是要乘个100000 真实结果：7860000 错误代码 (78 + round(random.uniform(1, 0), 2)) * 100000 运行结果 7880000.0 7816000.0 7859000.0 7834999.999999999 7820999.999999999 7859999.999999999 这肯定不对的啊..... 后来查到一篇文章讲了这个 https://xufive.blog.csdn.net/article/details/103816159 真是太恶心了 解决方法 from decimal import * Decimal((78 + round(random.uniform(1, 0), 2)) * 100000).quantize(Decimal('0')) 用了Decimal模块完美解决此问题 结果 7844000 7898000 7900000 7825000 7872000 7843000 7810000 7866000 7807000 7836000 7826000 7803000 7832000 7868000 7851000 7868000 ","link":"https://zhx6.github.io/A88jsrz2/"},{"title":"国内开源镜像站点汇总","content":"站点版 企业站 搜狐：http://mirrors.sohu.com/ 腾讯：https://mirrors.cloud.tencent.com/ 网易：http://mirrors.163.com/ 阿里：http://mirrors.aliyun.com/ 华为：https://mirrors.huaweicloud.com/ 教育站 上海交通大学：http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问） 华中科技大学：http://mirror.hust.edu.cn/（当前已用容量估计：4.83T） 清华大学：http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T） 北京理工大学：http://mirror.bit.edu.cn/web/ 兰州大学：http://mirror.lzu.edu.cn/ 中国科技大学：http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T） 大连东软信息学院：http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T） 东北大学：http://mirror.neu.edu.cn/ 大连理工大学：http://mirror.dlut.edu.cn/ 哈尔滨工业大学：http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问） 北京交通大学：http://mirror.bjtu.edu.cn/cn/ 中国地质大学：http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T） 浙江大学：http://mirrors.zju.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 中山大学：http://mirror.sysu.edu.cn/ 重庆大学：http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T） 北京化工大学：http://ubuntu.buct.edu.cn/（AndroidSDK镜像仅供校内使用，当前已用容量估计：1.72T） 南阳理工学院：http://mirror.nyist.edu.cn/ 中国科学院：http://www.opencas.org/mirrors/ 电子科技大学星辰工作室：http://mirrors.stuhome.net/（当前已用容量估计：1.08T） 西北农林科技大学：http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB） 其他站 首都在线科技股份有限公司（英文名CapitalOnlineDataService）：http://mirrors.yun-idc.com/ 常州贝特康姆软件技术有限公司：http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB） 公云PubYun（母公司为贝特康姆）：http://mirrors.pubyun.com/ 中国互联网络信息中心：http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB） 软件版 操作系统类 Ubuntu 阿里云：http://mirrors.aliyun.com/ubuntu-releases/ 网易：http://mirrors.163.com/ubuntu-releases/ 搜狐：http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了） 首都在线科技股份有限公司：http://mirrors.yun-idc.com/ubuntu-releases/ CentOS 网易：http://mirrors.163.com/centos/ 搜狐：http://mirrors.sohu.com/centos/ 阿里云：http://mirrors.aliyun.com/centos/ Tomcat、Apache 中国互联网络信息中心：http://mirrors.cnnic.cn/apache/ 华中科技大学：http://mirrors.hust.edu.cn/apache/ MySQL 搜狐：http://mirrors.sohu.com/mysql 中国科技技术大学：http://mirrors.ustc.edu.cn/mysql-ftp/Downloads PostgreSQL 浙江大学：http://mirrors.zju.edu.cn/postgresql/ MariaDB 中国科技技术大学：https://mirrors.ustc.edu.cn/mariadb/ VideoLAN 大连东软信息学院：http://mirrors.neusoft.edu.cn/videolan/ 中国科技大学：http://mirrors.ustc.edu.cn/videolan-ftp/ 开发工具类 Eclipse 中国科技大学：http://mirrors.ustc.edu.cn/eclipse/ 东北大学B：http://mirror.neu.edu.cn/eclipse/ 官方镜像列表状态地址 CentOS：http://mirror-status.centos.org/#cn Archlinux：https://www.archlinux.org/mirrors/status/ Ubuntu：https://launchpad.net/ubuntu/+cdmirrors Debian：http://mirror.debian.org/status.html FedoraLinux/FedoraEPEL：https://admin.fedoraproject.org/mirrormanager/mirrors Apache：http://www.apache.org/mirrors/#cn Cygwin：https://www.cygwin.com/mirrors.html ","link":"https://zhx6.github.io/HS8j95/"},{"title":"Python在Linux后台运行","content":"前言 写了一个python任务脚本，需要一直运行，刚开始使用了宝塔应用管理器和python管理器，都会出现运行着就停止运行的情况，而且上面还是显示在运行着....于是打算直接使用nohup运行 方法 先进入脚本文件的根目录 cd /www/Python/Auto/qianchuan/jiankong 使用nohup运行 nohup python -u main.py &gt; message.log 2&gt;&amp;1 &amp; 解释 nohup 和 &amp; 的区别 &amp; 是指在后台运行，但当用户退出(挂起)的时候，命令自动也跟着退出 nohup 运行 nohup --help Run COMMAND, ignoring hangup signals. 可以看到是“运行命令，忽略挂起信号”就是不挂断的运行，注意没有后台运行功能。 那么，我们可以巧妙的吧他们结合起来用就是 nohup COMMAND &amp; 这样就能使命令永久的在后台执行 -u python的输出进行了缓冲，导致message.log并不能够马上看到输出。 为python添加-u 参数，使得python不启用缓冲。 message.log 如果不填写的话，系统默认是写入到运行文件同位置output.out文件内，填写的话则会重定向到指定的文件 2&gt;&amp;1 0 表示stdin标准输入，用户键盘输入的内容 1 表示stdout标准输出，输出到显示屏的内容 2 表示stderr标准错误，报错内容 2&gt;&amp;1是一个整体，&gt;左右不能有空格，即将错误内容重定向输入到标准输出中去。 2&gt;&amp;1中的&amp;是为了区别文件1和1(标准输出)，假如为2&gt;1，就成了将错误内容输出到文件1中，而不是标准输出中。 其他 挂起后台进程以后想查看是否运行或者关闭该怎么办呢？别急，我们继续。 查看进程 ps aux | grep main.py main.py 是运行的文件 可以看到PID是12526 关闭进程 kill -9 12526 实时追踪文件输出到屏幕 tailf message.log ","link":"https://zhx6.github.io/python-zai-linux-hou-tai-yun-xing/"}]}